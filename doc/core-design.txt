= mwcollect v3 Core Design Paper (Draft) =

== Code Design Considerations ==

  The mwcollect v3 Core and all new plugins for it should be written in object
oriented, class focused C++ using the namespace mwcollectd for all core
components. There should be no direct callback functions, unless required by
external APIs. Instead such functionality should be implemented by abstract base
classes and pointers to implementation instances.

  Blocks of code should be indented by a single tab character ('\t', not
multiple other whitespace characters). There should be no indention because of
preprocsessor directives. Hungarian notation is strongly encouraged and speaking
variable and parameter names are a must.

== Network Core ==

  The mwcollect v3 Network Core must not be based on the assumption that the
network data is coming live from a network device. The input and output should
not be direct part of the network core, the Network Core should only be a glue
between data I/O modules and the rest of mwcollectd. Data I/O modules then
actually interface with the data sources. This ensures a high degree of
flexibility.

=== Live I/O ===

  Since collecting malware in realtime is still the main goal for mwcollect, a
live I/O module has to be created that interfaces with an IP network device via
the Berkeley Socket API.

=== Promiscious Sniff I/O ===

  mwcollect should be capable of being placed on a bridge in front of a large
network consisting of real windows hosts. mwcollect should then sniff the
traffic and

 * block traffic that is part of the actual malware propagation
 * spit out alerts
 * optionally impersonate the client being exploited and fetch the malware
   itself
   
  This requires a stream reassembly module.

=== Statically Captured I/O ===

  Additionally mwcollectd should be capable of reading static capture files from
network sniffers to ease incident analysis. This requires a stream reassmbly
module as well.

=== Interface to other Modules ===

  The core should provide an advanced interface to all non-I/O modules, giving
them the ability to

 * actively etablish TCP connections to other computers
 * host a server for accepting TCP connections on a given port
 * sending and receiving UDP datagrams
 
  All traffic must have the ability to be shared between multiple modules that
can subscribe or unsubscribe to certain connections (`Dialogues') at any point
before a module decides to overtake the Dialogue and start interactive actions.
Module must have the opportunity to subscribe a Dialogue even after that event
for sniffing or recording purposes.

  The Network Core may block certain functionality based upon the level of
interactivity (described below).

  
== Level of Interactivity ==

  mwcollectd should be configureable in three different levels of (network)
interactivity. On the highest level of interactivity, mwcollectd would open
server ports, fully emulate vulnerabilities and take apropriate actions upon
exploitation, e.g. downloading the malware. On the medium level of
interactivity, mwcollectd passively analyzes the network traffic passing by and
upon detection of an exploitation attempt tries to download the malware. On the
lowest level of interaction, mwcollectd simply passively analyzes the network
traffic and dispatches warnings if malware activity is detected. Optionally
a module to shut down the malware activity can be created.

  The high interactivity model of mwcollect has the by far highest prirotity in
development.


== Logging Facilities ==

  In addition to the logging to files, console, IRC and syslog that version 2.x
of mwcollect already provides, version 3.x should be also capable of logging to
Prelude IDS (www.prelude-ids.org) as well for an optimized sensor data
aggregation.

  The existing log system is already strong enough to filter logging by the
importance of a message, but currently lacks the ability to filter messages by
their abstract content. A tagging system for tagging messages should be
introduced, however limited to 32 static tags (due to performance issues). The
end user can then configure the log facilities to only log messages that follow
a certain pattern, e.g. `L_CRITICAL | (L_SUCCESS & L_INFO) | L_NEW_INTHEWILD'.
